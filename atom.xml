<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Daniel Ribeiro]]></title>
  <link href="http://danielribeiro.org/atom.xml" rel="self"/>
  <link href="http://danielribeiro.org/"/>
  <updated>2013-04-04T19:40:22-03:00</updated>
  <id>http://danielribeiro.org/</id>
  <author>
    <name><![CDATA[Daniel Ribeiro]]></name>
    <email><![CDATA[drgomesp@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Do you want to be a PHP Evangelist?]]></title>
    <link href="http://danielribeiro.org/do-you-want-to-be-a-php-evangelist/"/>
    <updated>2013-04-04T19:25:00-03:00</updated>
    <id>http://danielribeiro.org/do-you-want-to-be-a-php-evangelist</id>
    <content type="html"><![CDATA[<p>Before we dive into the subject of how to become a PHP Evangelist, we need to agree on the definition of the word “evangelism”. In order to become a PHP Evangelist it is essential to really understand its meaning.</p>

<!-- more -->


<blockquote><h5>This article was originally published on <a href="http://webandphp.com/April2013">April&#8217;s issue</a> of <a href="http://webandphp.com">Web &amp; PHP Magazine</a>.</h5></blockquote>

<p>What does “Evangelism” mean? Wikipedia gives us a detailed definition:</p>

<blockquote><p>“Evangelism is the preaching of the Christian Gospel or the practice of relaying information about a particular set of beliefs to others with the object of conversion”.</p></blockquote>

<p>Parts of the above sentence actually ring true when it comes to becoming a PHP Evangelist, even if unconsciously. To evangelize is to effectively transfer information regarding one set of beliefs to another, with the final goal of converting each individual to the original belief. Isn’t that what we do when we spread the word of PHP?!</p>

<p>The idea behind being a PHP Evangelist is for an individual to speak passionately about PHP and be able to have strong and durable arguments for PHP, if questioned about his “faith” in the technology. With this devout unbending faith in PHP it will encourage others to not only start using the language, but to also fall in love with it too. Maybe someday, those PHP beginners will become evangelists was well.</p>

<h3>What do you need to start doing to become a PHP Evangelist?</h3>

<p>Have an advanced knowledge of the language. After all, how can you have a solid and strong argument in any technical debate without knowing what you are debating about?</p>

<p>What sources should I use to help advance my knowledge of the language? You should definitely check out the official docs. When dealing with PHP, you will not find a better resource than the official documentation, make it your main tool to evolve, study and research every single document. You could look into the Zend Engineer Certification from Zend Technologies, which is currently the main certification for PHP. You take an exam which gives you questions on the language itself. Pass and you become a certified engineer. That will place you on the Yellow Pages of Zend Technologies, a good place to be for developers to contact you to ask advice.</p>

<p>Think out of the box. Technology evangelists are easy to spot, because they become the face of that technology within the community they work. PHP evangelists should become the reference point and a point of contact for other PHP programmers, especially if they have a question about the language.</p>

<p>How will I stand out from others in the community? There are many things you can do; one thing would be to look at all of the RFC’s (Request for Comments). Here you will have an overview page of all RFC’s related to PHP core development. That’s where you will find the community feature implementation proposals for the language. So when you’re next at a community event, discuss implementation proposals, offer your opinions on them. Knowing how the development of the technology you utilize is going can be a great advantage. Which features do the community wish to see into the language core? Which of these are actually going to be approved? Will they be in the next stable version? What discussions have been driving those proposals and approvals? Research.</p>

<p>You can also attend local events related to PHP, such as conferences that are often hosted in lots of different countries. Some countries even have organized groups of PHP users that host talks about relevant topics for the community. By attending events such as these or even by talking to the other attendants, you will be recognized. You could even host an event yourself!</p>

<h3>Contribution</h3>

<p>We all know that the theoretical knowledge about software engineering is important, but it is architecture and modelling which actually distinguishes the professionals from the amateurs in the world of programming. By taking good design and architectural decisions, you can achieve a more robust code with more quality and easier maintainability.</p>

<p>One of the great study tools you can use is opensource project contribution. Often, just by watching the development of open-source projects, you learn about some of the advanced features of that language, and consequently improve your technical knowledge.</p>

<p>Some people become evangelists just because they are leading or contributing to an impressive open-source project. That may not seem like a lot, but contributing to open source projects really makes the difference. Usually, open-source contributors have that “differential touch” that a successful company often needs in their team. They are concerned about code quality, maintainability and low coupling, for example. Usually they work outside of the box for the companies.</p>

<p>Open-source contributors are often taken as geeks or nerds, but the truth is they are the ones that do what they do because they love PHP. They are so passionate that they come home from work and keep coding, researching, learning from the projects and from the community. Everyone wants to be like that or at least have someone like that in their team.</p>

<p>If you are not sure where to start or what project to contribute to, GitHub will help you. There you can find a list of the most watched projects written in PHP: frameworks, libraries and even language interpreters. There is a huge selection of projects, which means that there is room for contribution or two from oneself.</p>

<h3>Be ready to lead</h3>

<p>Again, Wikipedia defines the concept of leadership for us:</p>

<blockquote><p>&#8220;&#8230; a process of social influence in which one person can enlist the aid and support of others in the accomplishment of a common task &#8230;&#8221;</p></blockquote>

<p>PHP evangelists are born to lead, to form opinions, influence the opinions of others and to have followers – and haters as well. Even if you think you were not born to be a leader or just don’t want to be one, you will have to get used to public speaking if you wish to become a PHP evangelist.</p>

<p>Leaders naturally influence the people they are surrounded by. This can be a good thing and a bad thing as well. Therefore leaders/evangelists should always be careful with what they say and teach.</p>

<h3>In the end &#8230;</h3>

<p>These are just a few tips to send you in the direction of becoming a PHP evangelist. That doesn’t mean you will be able to accomplish it easily, but if you have the passion for PHP, you’re already half way there.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Yes, you can have low coupling in a Symfony Standard Edition application!]]></title>
    <link href="http://danielribeiro.org/yes-you-can-have-low-coupling-in-a-symfony-standard-edition-application/"/>
    <updated>2013-03-02T19:45:00-03:00</updated>
    <id>http://danielribeiro.org/yes-you-can-have-low-coupling-in-a-symfony-standard-edition-application</id>
    <content type="html"><![CDATA[<p>Have you ever heard someone say full-stack frameworks are bad because they force you to write high coupling code? Well, that&#8217;s mostly malarkey! You can fight high coupling just by embracing <a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">S.O.L.I.D</a> principles and making smart architectural decisions.</p>

<!-- more -->


<p>Please notice:</p>

<blockquote><h4>This article might seem really big, and please excuse me for that, but I really think this topic deserves a lot of thought and attention.</h4></blockquote>

<p>And also keep in mind that:</p>

<blockquote><h4>This article is not a how-to type of article or a step-by-step tutorial. Its an article that presents some thougths and conceptual ideas to create better applications using a full-stack framework.</h4></blockquote>

<p>I once asked people on <a href="http://stackoverflow.com">stackoverflow</a> if <a href="http://stackoverflow.com/questions/9999433/should-everything-really-be-a-bundle-in-symfony-2">everything should really be a bundle</a> inside of a <a href="https://github.com/symfony/symfony-standard">Symfony Standard Edition</a> application. That question was actually the trigger for me to start looking deeper into the concepts of the framework and architecture in general.</p>

<h2>Bundles</h2>

<p>If you don&#8217;t know the concept of a bundle, the <a href="http://symfony.com/doc/current/book/page_creation.html#page-creation-bundles">documentation</a> explains it really well:</p>

<blockquote><p>A bundle is simply a structured set of files within a directory that implement a single feature. You might create a BlogBundle, a ForumBundle or a bundle for user management (many of these exist already as open source bundles). Each directory contains everything related to that feature, including PHP files, templates, stylesheets, JavaScripts, tests and anything else. Every aspect of a feature exists in a bundle and every feature lives in a bundle.</p></blockquote>

<p>The thing is the concept of bundle is actually really misunderstood by some people who use Symfony as a full-stack framework<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>. Without really understanding that concept, people tend to create bundles with lots of dependency between them and high coupling code beucase of the structure they come up with.</p>

<p>It makes a lot of sense to create bundles to integrate third-party libraries or solve specific and common problems into a Symfony application. Bundles like <a href="https://github.com/FriendsOfSymfony/FOSRestBundle">FOSRestBundle</a>, <a href="https://github.com/FriendsOfSymfony/FOSUserBundle">FOSUserBundle</a>, <a href="https://github.com/KnpLabs/KnpSnappyBundle">KnpSnappyBundle</a> or <a href="https://github.com/Respect/ValidationBundle">RespectValidationBundle</a> are great because they serve this purpose.</p>

<p>But when you are developing a web application, the heart of that application — you can call it the domain<sup id='fnref:2'><a href='#fn:2' rel='footnote'>2</a></sup>, the model or whatever else — is almost always independent from the framework you are using. You need your business specific code to be portable to any framework you want to at anytime during the development of that application.</p>

<p>So the question is: does it make sense to have domain, business specific code inside generic bundles? It really depends, but generally no. Business specific code is, basically, spread throughout a <a href="http://martinfowler.com/eaaCatalog/serviceLayer.html">service layer</a>, a <a href="http://martinfowler.com/eaaCatalog/domainModel.html">domain model</a> and some other <a href="http://martinfowler.com/eaaCatalog/index.html">important architectural concepts</a>. However, if you know some business code should be reused in two different applications of the same domain, maybe that&#8217;s the perfect time to wrap them in bundles.</p>

<p>Let&#8217;s take a look at a quick example: a simple web application, something like a website that holds both a blog and a forum for their users. Let&#8217;s consider, for the sake of the example, that the forum and the blog are accessed by the same users. Those users use the same login and password for both applications. The <code>User</code> entity would be shared by the <code>ForumBundle</code> and the <code>BlogBundle</code>, right?</p>

<pre><code>src/
└── Vendor/
    └── Product/
        ├── BlogBundle/
        ├── ForumBundle/
        └── SiteBundle/
</code></pre>

<p>Now comes a simple and recurring question: where should you place the <code>User</code> entity? Inside the <code>ForumBundle</code>? Or the <code>BlogBundle</code>? Shold you create a separate bundle to hold all features related to the user entity, like a <code>UserBundle</code>? For that problem, people come up with all kinds of solutions.</p>

<p>I&#8217;ve seen bundles created just with the purpose of holding entities, such as <code>EntityBundle</code>. I&#8217;ve also seen bundles that are considered to exist on a different layer in comparison to the other ones, so they come up with a <code>CommonBundle</code> or a <code>AppBundle</code>. Still, in my opinion, the problem persists. What is the problem again? Having to follow a bundle structure for a non-compliant case. Should the <code>User</code> entity really be inside a bundle? And that leads us to the directory structure of the project.</p>

<h2>Directory structure</h2>

<p>With the beauty of the Composer <a href="http://getcomposer.org/doc/01-basic-usage.md#autoloading">autoloader</a> — or any <a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md">PSR-0</a> compatible autoloader — you don&#8217;t have to worry about diverting from the Symfony full-stack directory structure. Just create your directories as you see fit, place your classes in there and you are good to go. Let&#8217;s take the same example from above to put this in pratice. What if we had a structure like this:</p>

<pre><code>src/
└── Vendor/
    └── Product/
        └── Bundle
            ├── BlogBundle/
            ├── ForumBundle/
            └── SiteBundle/
        └── Entity
            └── User.php
        ├── Repository
        └── Service
</code></pre>

<p>We now have a much more clean and verbose directory structure, that tells us the exact scope of the <code>User</code> entity, which is the whole application itself. Even if only one bundle is going to actually use the that entity or any of the code outside of the bundle structure, it&#8217;s still a good approach to separate them. In fact, this kind of design and architectural decision is what makes it possible to not have high coupling with the Symfony full-stack framework or any other framework.</p>

<p>So that leaves us with some other questions: what kind of code is left for the bundles themselves? How can you identify what code you should place inside bundles and what code you should isolate from them? Well, the answers for those questions are actually not simple. However, we can start by thinking on the application specific stuff.</p>

<p>The first thing that comes to mind is the <a href="http://symfony.com/doc/master/book/controller.html">controller</a>. The controller is nothing else than a piece of code created to solve the <em>delivery mechanism</em><sup id='fnref:3'><a href='#fn:3' rel='footnote'>3</a></sup> problem. Its job is basically to, having been activated by a <a href="http://martinfowler.com/eaaCatalog/frontController.html">front controller</a>, send a response to the client - on a web application, usually as a HTML page or a JSON response. Nothing else. Really, nothing else.</p>

<p>Composed by a really skinny code, you most likely won&#8217;t be able to reuse the controllers — and probably won&#8217;t want to as well, at least in most cases. With that in mind, don&#8217;t worry about them. Just keep them inside your application specific bundles — in our previous example, those would be <code>BlogBundle</code>, <code>ForumBundle</code>, <code>SiteBundle</code> — and you are fine.</p>

<p>The next thing that comes to mind when we think about application specific code is the <a href="http://symfony.com/doc/2.0/book/templating.html">view layer</a>. Just like the controllers, views are inside the delivery mechanism scope. They only exist because of the delivery mechanism of your application. If that is the web, than the views are probably going to be a bunch of <a href="http://symfony.com/doc/2.0/book/templating.html#templates">templates</a> to be displayed on the user&#8217;s screen.</p>

<p>Templates are even more specific than controllers. Rarely you will want to reuse them — maybe their concept or structure, but not as they are originally on each page. Since Symfony handles <a href="http://symfony.com/doc/2.0/book/templating.html#template-inheritance-and-layouts">template inheritance</a> pretty well, keep them inside your bundles too and they are going to be settled.</p>

<p>With all this informatin, let&#8217;s take a look at the evolution of our blog/forum/site example, starting by the directory structure with some more stuff on it.</p>

<pre><code>src/
└── Vendor/
    └── Product/
        └── Bundle
            └── BlogBundle/
            └── ForumBundle/
            └── SiteBundle/
                └── Controller/
                    └── IndexController.php
                └── Resources/
                    └── views/
                        └── index.html.twig
                └── ProductSiteBundle.php
        └── Entity
            └── User.php
        └── Repository
            └── UserRepository.php
        └── Service
            └── UserPasswordRetrievalService.php
</code></pre>

<p>Can you see the actual improvement here? All of your business specific code, the actual heart of your application, will be isolated from default structure of the framework. All you have actually following that structure is code that is, arguably, light and disposable, the controllers and the views. The important part, the part that <em>really</em> needs to be testable, maintanable and most importantly independent from any framework or library, is isolated in its own layer.</p>

<h2>Doctrine</h2>

<p>One of the greatest things about Symfony Standard Edition is that it already comes packed with Doctrine integration, thanks to <a href="https://github.com/doctrine/DoctrineBundle">DoctrineBundle</a>, from the Doctrine <a href="https://github.com/doctrine">organization</a>. This allows you to start developing your application domain layer, entities and repositories just by following some <a href="http://symfony.com/doc/master/book/doctrine.html">conventions</a>.</p>

<p>Doctrine is a really powerful persistance related set of libraries. One of its best features is the use of <a href="http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/basic-mapping.html#introduction-to-docblock-annotations">annotations</a> to parse documentation and transform it into metadata that can be processed later. Using Symfony, it is really common to see entities defined like this:</p>

<figure class='code'><figcaption><span>src/Vendor/Product/Entity/User.php</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="cp">&lt;?php</span>
</span><span class='line'><span class="k">namespace</span> <span class="nx">Vendor\Product\Entity</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">use</span> <span class="nx">Doctrine\ORM\Mapping</span> <span class="k">as</span> <span class="nx">ORM</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="sd">/**</span>
</span><span class='line'><span class="sd"> * @ORM\Entity</span>
</span><span class='line'><span class="sd"> * @ORM\Table(name=&quot;users&quot;)</span>
</span><span class='line'><span class="sd"> */</span>
</span><span class='line'><span class="k">class</span> <span class="nc">User</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="sd">/**</span>
</span><span class='line'><span class="sd">     * @ORM\Id</span>
</span><span class='line'><span class="sd">     * @ORM\Column(type=&quot;integer&quot;)</span>
</span><span class='line'><span class="sd">     * @ORM\GeneratedValue(strategy=&quot;AUTO&quot;)</span>
</span><span class='line'><span class="sd">     */</span>
</span><span class='line'>    <span class="k">protected</span> <span class="nv">$id</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="sd">/**</span>
</span><span class='line'><span class="sd">     * @ORM\Column(type=&quot;string&quot;)</span>
</span><span class='line'><span class="sd">     */</span>
</span><span class='line'>    <span class="k">protected</span> <span class="nv">$username</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="sd">/**</span>
</span><span class='line'><span class="sd">     * @ORM\Column(type=&quot;string&quot;)</span>
</span><span class='line'><span class="sd">     */</span>
</span><span class='line'>    <span class="k">protected</span> <span class="nv">$password</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>While having the flexibility of using annotations, you also contextualize information about the entities and the way they are persisted in the database inside the class definition ifselt. That is really awesome. If you don&#8217;t use annotations yet, maybe check out the <a href="http://www.slideshare.net/rdohms/annotations-in-php-confoo-2013">presentation</a> on them by <a href="https://twitter.com/rdohms">@rdohms</a>.</p>

<p>But everything that has advantages also have disadvantages. In my opinion — and this is really, really personal, the collateral damage annotations can cause in your code is high coupling with the library responsible for parsing them. That&#8217;s why I tend not to use annotations for domain specific code — entities, repositories, services and such, but only for application specific code.</p>

<p>Symfony also uses the power of annotations to allow you to define <a href="http://symfony.com/doc/2.1/bundles/SensioFrameworkExtraBundle/annotations/routing.html">routes</a> and <a href="http://symfony.com/doc/2.0/bundles/SensioFrameworkExtraBundle/annotations/view.html">templates</a>, with the power of <a href="https://github.com/sensio/SensioFrameworkExtraBundle">SensioFrameworkExtraBundle</a> — also packed with Symfony Standard Edition. I use them like there&#8217;s no tomorrow to define routes and templates for my controllers without really worrying about coupling.</p>

<p>My advice to you, with all that in mind, is to try and decouple your domain specific code the most you can from any library or framework. Using Symfony as a full-stack framework, that means to have all of Doctrine — or any other persistence library — configuration and mapping in isolated files, such as YAML or XML, like:</p>

<figure class='code'><figcaption><span>src/Vendor/Product/Resources/config/doctrine/User.orm.yml</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">Vendor\Product\Entity\User</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">entity</span>
</span><span class='line'>    <span class="l-Scalar-Plain">table</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">users</span>
</span><span class='line'>    <span class="l-Scalar-Plain">id</span><span class="p-Indicator">:</span>
</span><span class='line'>        <span class="l-Scalar-Plain">id</span><span class="p-Indicator">:</span>
</span><span class='line'>            <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">integer</span>
</span><span class='line'>            <span class="l-Scalar-Plain">generator</span><span class="p-Indicator">:</span> <span class="p-Indicator">{</span> <span class="nv">strategy</span><span class="p-Indicator">:</span> <span class="nv">AUTO</span> <span class="p-Indicator">}</span>
</span><span class='line'>    <span class="l-Scalar-Plain">fields</span><span class="p-Indicator">:</span>
</span><span class='line'>        <span class="l-Scalar-Plain">username</span><span class="p-Indicator">:</span>
</span><span class='line'>            <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">string</span>
</span><span class='line'>        <span class="l-Scalar-Plain">password</span><span class="p-Indicator">:</span>
</span><span class='line'>            <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">string</span>
</span></code></pre></td></tr></table></div></figure>


<p>Yes, that will make you write a considerable amount of aditional code and mantain a larger number of files, but I usually don&#8217;t worry about it too much. Since you are not going to be following the default Symfony structure, you might have to check the <a href="http://symfony.com/doc/master/reference/configuration/doctrine.html#mapping-configuration">documentation</a> on the Doctrine mapping configuration and see if you need any additional work to make everything flow as expected.</p>

<h2>Final thoughts</h2>

<p>To be honest, if you are comfortable with writting an application using some components to solve individual and isolated problems and not a full-stack framework, you will be able to write low coupling code easier. That doesn&#8217;t mean every application based on this kind of framework has high coupling code.</p>

<p>The bottom line is: low coupling it&#8217;s really more about how you design and structure your application architecture and less to what framework you choose to use. Symfony is extremely powerful and, at the same time, flexible enough to let you decide how to structure your code. That&#8217;s awesome, right?</p>

<p>Like I said at the beginning of this article, my intent was not to create a step-by-step guide or a tutorial on how to write low coupling code. That&#8217;s really something that comes with time and experience. My goal was to help you aim to the right direction on how to learn that faster and in a simpler way. And I hope I achieved that.</p>

<div class="footnotes">
<span>
Notes
</span>
    <ol>
        <li id='fn:1'>Read it as a Symfony Standard Edition application. <a href='#fnref:1' rev='footnote'>↩</a></li><li id='fn:2'>Concept extracted from Erich Evans&#8217; Domain Driven Design: Tackling Complexity in the Hearf of Software book <a href='#fnref:2' rev='footnote'>↩</a></li><li id='fn:3'>Concept extracted from a Keynote from Uncle Bob (Architecture, the Lost Years). <a href='#fnref:3' rev='footnote'>↩</a></li>
    </ol>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[O inimigo número um do programador: seu ego]]></title>
    <link href="http://danielribeiro.org/o-maior-inimigo-do-programador-o-ego/"/>
    <updated>2013-02-26T17:57:00-03:00</updated>
    <id>http://danielribeiro.org/o-maior-inimigo-do-programador-o-ego</id>
    <content type="html"><![CDATA[<p>Não há como negar: o inimigo número um de um programador é, sempre, seu próprio <a href="http://pt.wikipedia.org/wiki/Ego">ego</a>. Um monstro invisível que zela pelo seu código, sua conduta e perfil profissional e suas atitudes de trabalho em equipe. Será que precisamos derrubar este monstro para, finalmente, nos tornarmos realmente profissionais?</p>

<!-- more -->


<h2>Era uma vez</h2>

<p>Imagine que você trabalha em uma empresa pequena, onde a equipe de desenvolvedores não passa de cinco pessoas. Nessa equipe, você é um dos desenvolvedores com mais conhecimento técnico, mas não necessariamente com mais experiência.</p>

<p>Entre seus colegas, há diversos tipos de programadores: o acomodado — que já não se interessa mais em elevar seu conhecimento, pela razão que seja; o enrolador — que passa grande parte do tempo buscando não trabalhar; o esforçado — mas que está aquém das expectativas da empresa; entre outros.</p>

<p>Nesse meio de trabalho, independente do perfil de cada um, há pessoas com mais experiência — leia-se tempo de trabalho - ou menos que você. Há também aqueles que já estavam na empresa quando você chegou e, evidentemente, os que chegaram após a sua contratação.</p>

<p>Considere agora que você, no pouco tempo de trabalho que possui na empresa, já conquistou uma posição privilegiada em relação aos seus companheiros de trabalho — você é o oráculo de respostas para todos os questionamentos técnicos que surgem durante o processo de desenvolvimento.</p>

<p>Sendo assim, você depara constantemente com o código escrito pelos seus colegas e percebe que, em alguns casos, esse código necessita urgentemente de refatoração — até mesmo de testes automatizados, para garantir seu funcionamento. Qual a sua abordagem para com o seu colega para orientá-lo com relação a isso?</p>

<h2>Todos temos um ego pra cuidar</h2>

<p>Nos dias de hoje — e provavelmente nos dias mais antigos também, muitos programadores se prejudicam por darem muita atenção aos seus egos e pouca atenção às suas atitudes como profissionais. Eu diria, até mesmo, que alguns se auto boicotam e acabam levando outros consigo para barcos em naufrágio.</p>

<p>Será que não podemos elevar nossa autoestima inflando nosso ego com caprichos? Talvez sim. A situação se transforma em problema quando começa a afetar o seu perfil profissional e o seu comportamento, sua conduta dentro de uma empresa.</p>

<p><a href="http://en.wikipedia.org/wiki/Robert_Cecil_Martin">Uncle Bob</a> disse, certa vez<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>, que não há coisa mais terrível para um programador do que outro programador analisando seu código. Quem dirá falando sobre ele, questionando suas sdecisões? Apontando erros, então? Imagine!</p>

<p>Programadores são bichos do mato, com tendência ao egocentrismo e o isolamento social. Escrevem códigos já visando que seus colegas não o vejam. Até mesmo, em algumas situações, os deixam complexos só para os colegas não entenderem — e assim não terem a capacidade de apontar erros ou questionar qualquer coisa.</p>

<h2>Sejamos mais profissionais</h2>

<p>A tão esperada valorização do programador como profissional no mercado de trabalho começa por ele mesmo. Quando deixar de lado o ego e focar mais em compartilhar conhecimento — até mesmo pelas razões erradas, crescer profissionalmente em conjunto com seus colegas; ser mais altruísta em relação às suas atitudes; buscar um perfil dinâmico, pró-ativo; aí sim, começará o processo de transformação.</p>

<p>A mudança, quase sempre, vem de dentro. No nosso caso, de dentro de nós mesmos, como pessoas e profissionais e de dentro de nossas funções, métodos e classes. Seja uma pessoa que faz diferença positiva por onde passa. Quer programadores mais profissionais ao seu lado? Comece por mudar a sí mesmo. Afinal de contas, um exemplo vale mais que mil palavras.</p>

<div class="footnotes">
<span>
Notes
</span>
    <ol>
        <li id='fn:1'>The Clean Coder - A Code of Conduct for Professional Programmers (não lembro a página dessa citação) <a href='#fnref:1' rev='footnote'>↩</a></li>
    </ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ensaio sobre a Certificação Zend PHP 5.3: a preparação, a prova e o futuro como certificado]]></title>
    <link href="http://danielribeiro.org/ensaio-sobre-a-certificacao-zend-php-5-dot-3-a-preparacao-a-prova-e-o-futuro-como-certificado/"/>
    <updated>2013-02-22T17:01:00-03:00</updated>
    <id>http://danielribeiro.org/ensaio-sobre-a-certificacao-zend-php-5-dot-3-a-preparacao-a-prova-e-o-futuro-como-certificado</id>
    <content type="html"><![CDATA[<p>Recentemente, no dia 8 de fevereiro, realizei a tão esperada prova da <a href="http://www.zend.com/services/certification/">Certificação Zend PHP 5.3</a>. Foi uma prova extensa e bastante difícil, mas fui aprovado e me tornei um <a href="http://www.zend.com/en/store/education/certification/yellow-pages.php#show-ClientCandidateID=ZEND021458">Zend Certified Engineer</a>. Portanto, vou compartilhar com vocês, leitores, as minhas impressões a respeito da preparação, da prova e do futuro como membro das <a href="http://www.zend.com/en/store/education/certification/yellow-pages.php">Yellow Pages</a>.</p>

<!-- more -->


<h2>A preparação</h2>

<p>Pra falar a verdade, em sua forma mais nua e crua, a minha preparação se deu, principalmente, em um estado reativo. Poucas vezes depositei tempo, de forma ativa, ao estudo dos tópicos que contemplam a prova. Quando fiz a aquisição do <a href="http://shop.zend.com/en/zend-php5-certification-voucher.html">voucher</a>, quase um ano antes de realizar a prova, coloquei na minha cabeça que deveria criar um cronograma de estudos, fazer um planejamento para não fracassar.</p>

<p>Naquela época, tinha a intenção de utilizar todo o período de validade do voucher (um ano) para me preparar. Esse sentimento foi se diluindo ao passar do tempo; concentrei-me em outras atividades e passei por períodos de esquecimento — mesmo sabendo que teria que fazer a prova em algum momento.</p>

<p>Porém, durante todo esse tempo, fiz parte de um grupo do Google chamado <a href="http://groups.google.com.br/group/rumo-a-certificacao-php">Rumo à certificação PHP</a>, idealizado pelo Ari Stopassola Jr., o <a href="https://twitter.com/stopassola">@stopassola</a> do Twitter. Nesse grupo, são lançadas diversas perguntas, quase que diariamente, do nível da prova da certificação, e os membros enviam respostas correspondentes de acordo com seus conhecimentos e opiniões. Essa foi a grande ferramenta de estudo que adotei, mesmo que indiretamente, durante todo o período de preparação.</p>

<p>Como ressaltei anteriormente, sempre de maneira reativa, sem muita pretensão, enviei respostas para diversas perguntas lançadas no grupo. Em alguns momentos, discussões técnicas importantes foram levantadas por causa da discórdia entre as respostas de alguns membros. Discussões completamente sadias e extremamente importantes para a evolução do conhecimento daqueles envolvidos. De fato, o grupo me ajudou muito nessa jornada de conseguir a certificação.</p>

<h2>A prova</h2>

<p>Quando as primeiras questões começaram a ser jogadas na tela à minha frente, comecei a ficar assustado. Onde estavam todas aquelas questões que pensava que poderiam aparecer, relacionadas à <a href="http://php.net/manual/pt_BR/book.spl.php">SPL</a>, <a href="http://php.net/manual/pt_BR/book.stream.php">streams</a> ou <a href="http://php.net/manual/en/language.oop5.php">classes e objetos</a>? Onde estavam aquelas questões mais complexas sobre a <a href="http://php.net/manual/en/language.basic-syntax.php">sintaxe</a> da linguagem? Realmente, não sei.</p>

<p>Fui bombardeado com questões atípicas dentro da minha realidade de trabalho. Muitas sobre <a href="http://php.net/manual/en/ini.list.php">diretrizes</a> de configuração do PHP — questões &#8220;pega ratão&#8221;, com erros na escrita das diretrizes, outras mais conceituais, relacionadas aos [conceitos] de <a href="http://php.net/manual/en/security.php">segurança</a> e <a href="http://php.net/manual/pt_BR/book.filter.php">filtragem de dados</a> — principalmente, no contexto de banco de dados.</p>

<p>O meu problema com essas questões não era a respeito do tema — muito pelo contrário, os temas são muito relevantes e atuais, mas sim com a forma como foram elaboradas. Me parece que o pessoal que elabora a prova está mais preocupado com as pessoas que procuram decorar os nomes de funções e diretrizes do PHP ou identificar padrões absurdos e exagerados do que aquelas com o conhecimento técnico sobre a utilização desses.</p>

<p>Não posso negar, também, que chutei algumas questões, por não ter a menor ideia sobre a resposta. De fato, algumas questões são até confusas em seus enunciados e podem causar problemas para quem está realizando a prova.</p>

<p>Por fim, fiquei muito satisfeito com o processo de revisão. Depois de um longo tempo fazendo a prova, você cai numa tela de revisão, onde vê, de maneira geral, todas as questões a que respondeu e que, eventualmente, esqueceu de marcar alguma opção — no caso das perguntas de múltila escolha. Isso foi extremamente importante para mim, que deixei umas três ou quatro questões incompletas.</p>

<h2>O futuro</h2>

<p>Não vou dizer que minha vida profissional mudou drasticamente desde que me tornei certificado — seria demagogia de minha parte. De fato, também não passei a me ver de forma diferente tecnicamente, afinal de contas, meu conhecimento é o mesmo de quando ainda não era certificado. Assim sendo, valeu a pena? Sem sombra de dúvidas.</p>

<p>O fato de ser certificado lhe garante muitos benefícios além do conhecimento adquirido para ser aprovado na prova. Um desses benefícios é passar a se destacar frente à comunidade PHP. Não sei como funciona a cabeça de cada um, mas na minha, sempre fez mais sentido ouvir a opinião de certificados do que não certificados. Não é uma questão de preconceito; simplesmente um profissional que é certificado possui — ou, pelo menos, deveria — mais conhecimento técnico sobre a linguagem.</p>

<p>Outra questão são as tão faladas <a href="http://www.zend.com/en/store/education/certification/yellow-pages.php">Yellow Pages</a> da Zend. Conheço profissionais que receberam propostas de emprego ou convocações para processos seletivos em empresas grandes — algumas do exterior — somente por estarem nas páginas amarelas, como certificados. E isso, independente da opinião de cada um, é um fato.</p>

<p>Como será o meu futuro a partir de agora? Igual. Continuarei sendo o mesmo profissional, com o perfil de busca constante por expansão e compartilhamento de conhecimento, contribuição e referência. A única diferença agora é um selo de certificação. Isso me trará benefícios que não teria antes? Talvez. Saberei ao longo dos próximos anos. Ou, talvez, nunca.</p>
]]></content>
  </entry>
  
</feed>